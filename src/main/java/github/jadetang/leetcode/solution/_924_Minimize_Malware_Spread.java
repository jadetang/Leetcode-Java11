package github.jadetang.leetcode.solution;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;

public class _924_Minimize_Malware_Spread {


    @Test
    void test() {
        assertEquals(2, minMalwareSpread(new int[][]
                {{1,1,0},{1,1,0},{0,0,1}}, new int[] {0, 1 ,2}));
    }

    @Test
    void test2() {
        assertEquals(3, minMalwareSpread(new int[][]
                {{1,0,0,0},{0,1,0,0},{0,0,1,1},{0,0,1,1}}, new int[] {3,1}));
    }

    @Test
    void test3() {
        assertEquals(0, minMalwareSpread(new int[][]
                {{1,1,0},{1,1,0},{0,0,1}}, new int[] {0, 1}));
    }

    UnionFind unionFind;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        unionFind = new UnionFind(graph.length);
        int n = graph.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    unionFind.union(i, j);
                }
            }
        }
        Map<Integer, Integer> clusterSize = new HashMap<>();
        for (int i = 0; i < graph.length; i++) {
            clusterSize.put(unionFind.find(i), clusterSize.getOrDefault(unionFind.find(i), 0) + 1);
        }

        Map<Integer, Integer> sameRootCount = new HashMap<>();
        for (int i : initial) {
            int root = unionFind.find(i);
            sameRootCount.put(root, sameRootCount.getOrDefault(root, 0) + 1);
        }

        int ans = -1;
        int maxClusterSize = -1;
        for (int i : initial) {
            int root = unionFind.find(i);
            if (sameRootCount.get(root) == 1) {
                int size = clusterSize.get(root);
                if (size > maxClusterSize) {
                    maxClusterSize = size;
                    ans = i;
                }else if (size == maxClusterSize && i < ans) {
                    ans = i;
                }
            }
        }
        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int node: initial)
                ans = Math.min(ans, node);
        }
        return ans;
    }

    public static class UnionFind {

        int[] array;

        public UnionFind(int n) {
            array = new int[n];
            for (int i = 0; i < n; i++) {
                array[i] = i;
            }
        }

        int find(int n) {
            while (n != array[n]) {
                array[n] = array[array[n]];
                n = array[n];
            }
            return n;
        }

        void union(int i, int j) {
            int rooti = find(i);
            int rootj = find(j);
            if (rooti != rootj) {
                array[rootj] = rooti;
            }
        }
    }
}
